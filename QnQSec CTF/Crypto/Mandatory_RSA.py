#!/usr/bin/env python3
# Prova Wiener attack su n,e (richiede gmpy2)
# pip install gmpy2

import gmpy2
from gmpy2 import mpz, isqrt, is_square, invert

n = mpz(30610867131545893573245403370929044810375908252345734515216335567761070674235240557970829245356614030481955825874376565524126172250295479286829004996105122106474627414932278394880727207687247106535964451736524423676062227917939094755601312619938974463767105253817030590414646900543888347805544511989816392901347341338737906837896070023751031260815782973250734600300683094949304509692321753534435264794596296780586539085130232106649876660029506699244567866816756904364396378546670735017278059889632347338673055259053699246622809620909022329749464060132071464884484682112534813343645706384624586841979729464134335809829)
e = mpz(13118943056376811531390887158969590633018246393862457649378429529040458860386531667701783962295691727349409639660447099510339788107269491122926716426902195188489126034970976454948883089008820188515413336458510467289740954821973897752400562551402417627328759394493013110177705814518809291916661933709921311243284600780240090861401353930215487292827235572235250164436683130292475464090785626013810206032736933354696930489144983575446495078404329829091193678240029445525658582548485531996972340914370823232033916046942293331266006647674886928834212203547468218609381456317192256524737280398698305720035095438106008915543)
c = mpz(18491889164810617543569456750416875989184817880137548014973592642069416208831086398288449741333647958301433206462225905089767171227296166302076329585813204145393998300807912284373441125769784091235480355305999860836226228064817001671079683866140595167104080925862489688205706558563994071054217252661751197090938128540101902284587959897970686920835999487758527543265902558413502613239565915919268373782402562042295965144636399280059309987259722405692758942811072888497222424752062745376152606372092707679048892146955016482797824514120865462676167840311292744307891590740707933408465096337716317714272609074408402855672)

def continued_fraction(a, b):
    cf = []
    while b:
        q = a // b
        cf.append(int(q))
        a, b = b, a - q*b
    return cf

def convergents(cf):
    conv = []
    p0, p1 = 1, cf[0]
    q0, q1 = 0, 1
    conv.append((p1, q1))
    for a in cf[1:]:
        p = a*p1 + p0
        q = a*q1 + q0
        conv.append((p, q))
        p0, p1 = p1, p
        q0, q1 = q1, q
    return conv

def wiener(e, n):
    cf = continued_fraction(e, n)
    conv = convergents(cf)
    for k, d in conv:
        if k == 0:
            continue
        if (e*d - 1) % k != 0:
            continue
        phi = (e*d - 1) // k
        s = n - phi + 1
        discr = s*s - 4*n
        if discr >= 0 and is_square(discr):
            t = isqrt(discr)
            p = (s + t) // 2
            q = (s - t) // 2
            if p*q == n:
                return (int(p), int(q), int(d))
    return None

res = wiener(e, n)
if res:
    p,q,d = res
    print("[+] Trovato! p =", p)
    print("    q =", q)
    print("    d =", d)
    m = pow(int(c), d, p*q)
    try:
        print("    messaggio (utf-8):", bytes.fromhex(hex(m)[2:]).decode())
    except Exception:
        print("    messaggio int:", m)
else:
    print("[-] Wiener attack fallito (d probabilmente non piccolo entro il bound).")